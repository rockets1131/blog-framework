---
title: 正则表达式学习
date: 2016-10-09 15:24:32
tags: JavaScript
---
## 预定义的特殊字符
### 转意字符 `\`
匹配将依照下列规则：

反斜杠,对于其后的平常被当作字面量的字符，将其转义为特殊字符。比如，/b/匹配了字符'b'.通过在b的前面放一个反斜杠，即用作/\b/，这个字符变成了一个特殊意义的字符，意思是匹配一个字符边界。
反斜杠也可以将其后的特殊字符，转义为字面量。例如，模式 /a\*/ 代表会匹配 0 个或者多个 a。相反，模式 /a\\*/ 将 '\*' 的特殊性移除，从而可以匹配像 'a\*' 这样的字符串。
使用 new RegExp("pattern") 的时候不要忘记将 \ 进行转义，因为 \ 在字符串里面也是一个转义字符。
  
  字符 | 正则 | 描述
 ----  | --- | -------
 \t | /\t/ | 制表符
 \n | /\n/ | 制表符
 \r | /\r/ | 回车符
 \f | /\f/ | 换页符
 \a | /\a/ | alert字符
 \e	| /\e/ | escape字符
 \cX | /\cX/ | 与X相对应的控制字符
 \b | /\b/ | 与回退字符
 \v | /\v/ | 垂直制表符
 \0 | /\0/ | 空字符
## 字符类
### 简单类
 
我们可以用[]把字符括起来,让[]整体对应一个字符,表示其中一个字符。如
``` js
/[abc]/.test("a"); //true
/[abc]/.test("b"); //true
/[abc]/.test("c"); //true
```
### 负向类

在[]里，前面加个元字符进行取反，表示匹配不在括号里面的字符。
``` js
/[^abc]/.test("a"); //false
/[^abc]/.test("6"); //true
```
### 范围类
有时匹配的东西过多，而且类型又相同，我们在中间加横线表示范围。
``` js
/[a-f]/.test("b"); //true
/[a-f]/.test("k"); //false
```
### 组合类
用中括号匹配不同类型的单个字符。
``` js
/[a-m1-5]/.test("a"); //true
/[a-m1-5]/.test("r"); //false
```
### 预定义类
 字符 | 等同于 | 描述
 --- | ---- | ----
 . | [^\n\r] | 除了换行和回车之外的任意字符
 \d | [0-9] | 数字字符
 \D | [^0-9] | 非数字字符
 \s | [\t\n\x0B\f\r] | 空白字符
 \S | [^ \t\n\x0B\f\r] | 非空白字符
 \w | [a-zA-Z_0-9] | 单词字符(所有的字母)
 \W | [^a-zA-Z_0-9] | 非单词字符
 
## 量词
 代码 | 类型 | 描述
 --- | --- | ---
 ? | 软性量词 | 出现零次或一次
 * | 软性量词 | 出现零次或多次(任意次)
 + | 软性量词 | 出现一次或多次（至少一次)
 {n} | 硬性量词 | 对应零次或者n次
 {n,m} | 软性量词 | 出现n到m次
 {n,} | 软性量词 | 至少出现n次(+的升级版)
 
 > /[\u4e00-\u9fa5]/用于匹配单个汉字。
 
### 贪婪量词
上面提到的所有简单量词。匹配整个字符串，如果匹配不了，再从后向前去掉一个字符，再检查字符串是否匹配，不断重复直到长度为零。
### 隋性量词
在简单量词后加问号。从前面匹配第一个字符，如果匹配不了，再向后添加一个,其工作方式与贪婪量词相反。
``` js
var re1 = /.*bbb/g;//贪婪
var re2 = /.*?bbb/g;//惰性

re1.test("abbbaabbbaaabbbb1234"); //true
"abbbaabbbaaabbbb1234".match(re1); //abbbaabbbaaabbbb
 
re2.test("abbbaabbbaaabbbb1234"); //true
"abbbaabbbaaabbbb1234".match(re2); //abbb,aabbb,aaabbb
```
## 捕获
匹配并且记住匹配项。括号被称为捕获括号。
``` js
/(dog){2}/.test("dogdog"); //true
```
### 反向引用
反向引用标识由正则表达式中的匹配组捕获的子字符串。每个反向引用都由一个编号或名称来标识，并通过“\编号”表示法进行引用。
``` js
var color = "#990000";
/#(\d+)/.test(color);
RegExp.$1 ;//990000
/(dog)\1/.test("dogdog" //true
```
### 非捕获性分组

非捕获性分组，不会创建反向引用，在分组的左括号的后面紧跟一个问号和冒号。
``` js
var color = "#990000";
/#(?:\d+)/.test(color);
RegExp.$1; //""
```
### 正向肯定
x(?=y) 匹配'x'仅仅当'x'后面不跟着'y'。
``` js
/Jack(?=Sprat)/.exec('JackSprat'); //Jack
```
### 正向否定
x(?!y) 匹配'x'仅仅当'x'后面不跟着'y'。
``` js
/\d+(?!\.)/.exec('3.141'); //141
```
### 候选
x|y 匹配‘x’或者‘y’。
``` js
/green|red/.exec('green apple'); //green
```

## 边界
正则 | 名称 | 描述
--- | --- | ---
^ | 开头 | 匹配输入的开始。
$ | 结尾	 | 匹配输入的结束
\b | 单词边界 | 指[a-zA-Z_0-9]之外的字符
\B | 非单词边界 | 匹配一个非单词边界

### 单词边界
匹配一个词的边界。一个词的边界就是一个词不被另外一个词跟随的位置或者不是另一个词汇字符前边的位置。注意，一个匹配的词的边界并不包含在匹配的内容中。换句话说，一个匹配的词的边界的内容的长度是0。
``` js
/\bm/.exec('moon'); // 'm'
/oo\b/.exec('moon'); // null 因为'oo'被一个词汇字符'n'紧跟着。
```
### 非单词边界
匹配一个非单词边界。他匹配一个前后字符都是相同类型的位置：都是单词或者都不是单词。一个字符串的开始和结尾都被认为是非单词。
/\B../.exec('noonday'); // 'oo'
/y\B./.exec('possibly yesterday'); // 'ye'

使用正则表达式
方法 | 描述
--- | ---
exec | 一个在字符串中执行查找匹配的RegExp方法，它返回一个数组（未匹配到则返回null）。
test | 一个在字符串中测试是否匹配的RegExp方法，它返回true或false。
match | 一个在字符串中执行查找匹配的String方法，它返回一个数组或者在未匹配到时返回null。
search | 一个在字符串中测试匹配的String方法，它返回匹配到的位置索引，或者在失败时返回-1。
replace | 一个在字符串中执行查找匹配的String方法，并且使用替换字符串替换掉匹配到的子字符串。
split | 一个使用正则表达式或者一个固定字符串分隔一个字符串，并将分隔后的子字符串存储到数组中的String方法。
